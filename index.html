
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CryptoLocker - NFT DeFi Platform</title>
  <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a0a;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  overflow-x: hidden;
}
.bg-animation {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background: radial-gradient(circle at 20% 50%, rgba(0, 255, 65, 0.1) 0%, transparent 50%),
              radial-gradient(circle at 80% 80%, rgba(0, 255, 65, 0.15) 0%, transparent 50%);
  animation: pulse 8s ease-in-out infinite;
}
@keyframes pulse {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}
.grid-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    linear-gradient(rgba(0, 255, 65, 0.03) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0, 255, 65, 0.03) 1px, transparent 1px);
  background-size: 50px 50px;
  z-index: 1;
  pointer-events: none;
}
header {
  position: relative;
  z-index: 100;
  background: rgba(10, 10, 10, 0.9);
  backdrop-filter: blur(10px);
  border-bottom: 2px solid #00ff41;
  padding: 1rem 2rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 1rem;
}
.logo {
  font-size: 1.5rem;
  font-weight: bold;
  color: #00ff41;
  text-shadow: 0 0 10px #00ff41;
}
.header-controls {
  display: flex;
  gap: 1rem;
  align-items: center;
  flex-wrap: wrap;
}
.connection-status {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  background: rgba(0, 255, 65, 0.1);
  border-radius: 20px;
  font-size: 0.9rem;
}
.status-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #ff4444;
  animation: blink 2s infinite;
}
.status-dot.connected {
  background: #00ff41;
  box-shadow: 0 0 10px #00ff41;
  animation: none;
}
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}
.connect-buttons {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}
.container {
  position: relative;
  z-index: 10;
  max-width: 1400px;
  margin: 0 auto;
  padding: 2rem;
}
.dashboard {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 2rem;
  margin-bottom: 2rem;
}
.card {
  background: rgba(26, 26, 26, 0.8);
  backdrop-filter: blur(10px);
  border: 2px solid rgba(0, 255, 65, 0.3);
  border-radius: 15px;
  padding: 1.5rem;
  box-shadow: 0 8px 32px rgba(0, 255, 65, 0.1);
  transition: all 0.3s ease;
}
.card:hover {
  border-color: #00ff41;
  box-shadow: 0 8px 32px rgba(0, 255, 65, 0.3);
  transform: translateY(-5px);
}
.card h2 {
  margin-bottom: 1rem;
  font-size: 1.3rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
input, textarea, select, button {
  width: 100%;
  font-size: 1rem;
  padding: 0.8rem;
  border-radius: 8px;
  border: 1px solid rgba(0, 255, 65, 0.3);
  background: rgba(10, 10, 10, 0.5);
  color: #00ff41;
  font-family: 'Courier New', monospace;
  transition: all 0.3s ease;
}
input:focus, textarea:focus, select:focus {
  outline: none;
  border-color: #00ff41;
  box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
}
button {
  background: transparent;
  border: 2px solid #00ff41;
  cursor: pointer;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 1px;
}
button:hover:not(:disabled) {
  background: #00ff41;
  color: #0a0a0a;
  box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
button.metamask {
  border-color: #f6851b;
  color: #f6851b;
}
button.metamask:hover:not(:disabled) {
  background: #f6851b;
  color: #fff;
}
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}
.stat-item {
  background: rgba(0, 255, 65, 0.1);
  padding: 1rem;
  border-radius: 8px;
  text-align: center;
}
.stat-value {
  font-size: 2rem;
  font-weight: bold;
  color: #00ff41;
  text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
}
.stat-label {
  font-size: 0.9rem;
  opacity: 0.7;
  margin-top: 0.5rem;
}
.notification {
  position: fixed;
  top: 100px;
  right: 20px;
  background: rgba(26, 26, 26, 0.95);
  border: 2px solid #00ff41;
  padding: 1rem 2rem;
  border-radius: 10px;
  z-index: 1000;
  box-shadow: 0 8px 32px rgba(0, 255, 65, 0.3);
  animation: slideIn 0.3s ease;
  max-width: 400px;
}
@keyframes slideIn {
  from {
    transform: translateX(400px);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}
label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
}
input[type="checkbox"] {
  width: auto;
  cursor: pointer;
}
.payment-section {
  background: rgba(0, 255, 65, 0.05);
  border: 1px dashed rgba(0, 255, 65, 0.3);
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1rem;
  text-align: center;
}
input[type="file"] {
  padding: 0.5rem;
  font-size: 0.9rem;
}
.auth-method {
  background: rgba(0, 255, 65, 0.05);
  border: 1px solid rgba(0, 255, 65, 0.2);
  border-radius: 8px;
  padding: 0.5rem;
  margin-top: 0.5rem;
  font-size: 0.85rem;
  text-align: center;
}
.sfa-login-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  z-index: 9999;
  justify-content: center;
  align-items: center;
}
.sfa-login-content {
  background: rgba(26, 26, 26, 0.95);
  border: 2px solid #00ff41;
  border-radius: 15px;
  padding: 2rem;
  max-width: 400px;
  width: 90%;
}
.sfa-login-content h3 {
  color: #00ff41;
  margin-bottom: 1.5rem;
  text-align: center;
}
.sfa-buttons {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.close-modal {
  float: right;
  cursor: pointer;
  font-size: 1.5rem;
  color: #ff4444;
}
.sfa-input-group {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.sfa-input-group input {
  margin: 0;
}
.sfa-info {
  background: rgba(0, 255, 65, 0.05);
  border: 1px solid rgba(0, 255, 65, 0.2);
  border-radius: 8px;
  padding: 1rem;
  font-size: 0.85rem;
  margin-top: 1rem;
  text-align: center;
}
.wallet-info {
  background: rgba(0, 255, 65, 0.05);
  border: 1px solid rgba(0, 255, 65, 0.3);
  border-radius: 8px;
  padding: 1rem;
  margin-top: 1rem;
  font-size: 0.85rem;
}
.wallet-address {
  word-break: break-all;
  color: #00ff41;
  font-weight: bold;
  margin: 0.5rem 0;
}
@media (max-width: 768px) {
  header {
    flex-direction: column;
  }
  .container {
    padding: 1rem;
  }
  .dashboard {
    grid-template-columns: 1fr;
  }
}
  </style>
</head>
<body>
  <div class="bg-animation"></div>
  <div class="grid-overlay"></div>
  
  <!-- SFA Login Modal -->
  <div id="sfaLoginModal" class="sfa-login-modal">
    <div class="sfa-login-content">
      <span class="close-modal" onclick="closeSFAModal()">√ó</span>
      <h3>üîê Web3Auth Login</h3>
      <div class="sfa-buttons">
        <div class="sfa-input-group">
          <label for="sfaEmail">Email Address:</label>
          <input type="email" id="sfaEmail" placeholder="your@email.com" />
        </div>
        <button onclick="loginWithSFA()" style="border-color: #00ff41; color: #00ff41;">
          üîë Generate Wallet & Login
        </button>
      </div>
      <div class="sfa-info">
        ‚úÖ No OAuth needed<br/>
        ‚úÖ Wallet auto-generated<br/>
        ‚úÖ Non-custodial access<br/>
        ‚ö†Ô∏è Same email = same wallet<br/>
        üí° Fund wallet to transact
      </div>
      <div id="walletInfo" class="wallet-info" style="display:none;">
        <div id="walletMessage"></div>
        <div class="wallet-address" id="walletAddress"></div>
        <div id="walletBalance"></div>
      </div>
    </div>
  </div>
  
  <header>
    <div class="logo">üîê CryptoLocker</div>
    <div class="header-controls">
      <div class="connection-status">
        <span class="status-dot" id="statusDot"></span>
        <span id="connectionText">Not Connected</span>
      </div>
      <div class="connect-buttons">
        <button id="connectMetaMask" class="metamask">ü¶ä MetaMask</button>
        <button id="connectSFA" style="border-color: #00ff41; color: #00ff41;">üîê Web3Auth</button>
        <button id="disconnectBtn" style="display:none; border-color:#ff4444; color:#ff4444;">Disconnect</button>
      </div>
    </div>
  </header>
  
  <div class="container">
    <div class="dashboard">
      <!-- Stats Card -->
      <div class="card">
        <h2>üìä Platform Stats</h2>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value">‚úì</div>
            <div class="stat-label">Contract Active</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="userBalance">0</div>
            <div class="stat-label">Your Balance</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="chainName">-</div>
            <div class="stat-label">Network</div>
          </div>
        </div>
        <div class="auth-method" id="authMethod" style="display:none;">
          Connected via: <span id="authType">-</span>
        </div>
      </div>
      
      <!-- Quick Mint NFT -->
      <div class="card">
        <h2>‚ö° Quick Mint NFT</h2>
        <div class="payment-section">
          <div style="font-size: 1.2rem;">üí∞ Minting Fee: 0.01 ETH</div>
        </div>
        <form id="quickMintForm">
          <input type="text" id="nftName" placeholder="NFT Name" required />
          <textarea id="nftDescription" placeholder="Description" rows="3"></textarea>
          <select id="contentType">
            <option value="image">Image</option>
            <option value="video">Video</option>
            <option value="audio">Audio</option>
            <option value="text">Text</option>
          </select>
          <input type="file" id="nftFile" accept="image/*,video/*,audio/*,text/*" />
          <button type="submit">üé® Mint NFT (0.01 ETH)</button>
        </form>
      </div>
      
      <!-- Create Collection -->
      <div class="card">
        <h2>üìÅ Create Collection</h2>
        <form id="createCollectionForm">
          <input type="text" id="collectionName" placeholder="Collection Name" required />
          <textarea id="collectionDescription" placeholder="Description" rows="3"></textarea>
          <button type="submit">üì¶ Create Collection</button>
        </form>
      </div>
      
      <!-- Lock Tokens -->
      <div class="card">
        <h2>üîí Lock Tokens</h2>
        <form id="lockForm">
          <input type="text" id="tokenAddress" placeholder="Token Contract Address" required />
          <input type="number" id="lockAmount" placeholder="Amount" step="0.01" required />
          <select id="lockDuration">
            <option value="7">7 Days</option>
            <option value="30">30 Days</option>
            <option value="90">90 Days</option>
            <option value="180">180 Days</option>
            <option value="365">1 Year</option>
          </select>
          <label>
            <input type="checkbox" id="useYield" />
            <span>Enable Aave Yield Generation</span>
          </label>
          <button type="submit">üîê Lock Tokens</button>
        </form>
      </div>
    </div>
  </div>
  
  <!-- Load JavaScript from Part 2 -->
  <script src="cryptolocker.js"></script>
</body>
</html> 
// ===================================
// CryptoLocker DeFi Platform - Main JavaScript
// Part 2: All Logic & Smart Contract Interactions
// ===================================

// Configuration
const CONFIG = {
  CONTRACT_ADDRESS: '0x82ecB5c11Eda49f8E77e8617C360A5645F8612D1',
  BASE_CHAIN_ID: 8453,
  BASE_CHAIN_HEX: '0x2105',
  BASE_RPC: 'https://mainnet.base.org',
  CONTRACT_ABI: [
    "function mintNFT(string name, string description, string contentType, string ipfsUrl, uint256 royaltyPercent, string tokenURI) public payable returns (uint256)",
    "function createCollection(string name, string description) public returns (uint256)",
    "function lockTokens(address tokenAddress, uint256 amount, uint256 duration, bool useYield) public"
  ],
  PINATA: {
    API_KEY: 'b831f3b9a2d859df00fc',
    API_SECRET: '238033d405b10283e4a617c6238e15f8b03cafb0b37be62a0819f1f3bdab90d4',
    GATEWAY: 'gateway.pinata.cloud'
  }
};

// Global State
let provider = null;
let signer = null;
let contract = null;
let userAddress = null;
let authType = null;

// ===================================
// UI Helper Functions
// ===================================

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = 'notification';
  notification.textContent = message;
  if (type === 'error') notification.style.borderColor = '#ff4444';
  if (type === 'success') notification.style.borderColor = '#00ff41';
  document.body.appendChild(notification);
  setTimeout(() => notification.remove(), 5000);
}

function updateConnectionUI(connected, address = null, method = null) {
  const statusDot = document.getElementById('statusDot');
  const connectionText = document.getElementById('connectionText');
  const metamaskBtn = document.getElementById('connectMetaMask');
  const sfaBtn = document.getElementById('connectSFA');
  const disconnectBtn = document.getElementById('disconnectBtn');
  const authMethodDiv = document.getElementById('authMethod');
  const authTypeSpan = document.getElementById('authType');
  
  if (connected && address) {
    statusDot.classList.add('connected');
    connectionText.textContent = address.slice(0, 6) + '...' + address.slice(-4);
    metamaskBtn.style.display = 'none';
    sfaBtn.style.display = 'none';
    disconnectBtn.style.display = 'block';
    authMethodDiv.style.display = 'block';
    authTypeSpan.textContent = method || 'Unknown';
  } else {
    statusDot.classList.remove('connected');
    connectionText.textContent = 'Not Connected';
    metamaskBtn.style.display = 'block';
    sfaBtn.style.display = 'block';
    disconnectBtn.style.display = 'none';
    authMethodDiv.style.display = 'none';
  }
}

function openSFAModal() {
  document.getElementById('sfaLoginModal').style.display = 'flex';
  document.getElementById('walletInfo').style.display = 'none';
}

function closeSFAModal() {
  document.getElementById('sfaLoginModal').style.display = 'none';
  document.getElementById('sfaEmail').value = '';
  document.getElementById('walletInfo').style.display = 'none';
}

// ===================================
// Network Management
// ===================================

async function checkAndSwitchNetwork() {
  try {
    const network = await provider.getNetwork();
    
    if (network.chainId !== CONFIG.BASE_CHAIN_ID) {
      showNotification('‚ö†Ô∏è Wrong network detected. Switching to Base...', 'info');
      await switchToBase();
      
      // Verify switch was successful
      const newNetwork = await provider.getNetwork();
      if (newNetwork.chainId !== CONFIG.BASE_CHAIN_ID) {
        throw new Error('Failed to switch to Base network');
      }
      
      showNotification('‚úÖ Switched to Base network', 'success');
      return true;
    }
    
    return true;
  } catch (error) {
    console.error('Network switch error:', error);
    throw new Error('Please switch to Base network manually');
  }
}

async function switchToBase() {
  try {
    await window.ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: CONFIG.BASE_CHAIN_HEX }]
    });
    return true;
  } catch (error) {
    if (error.code === 4902) {
      try {
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: CONFIG.BASE_CHAIN_HEX,
            chainName: 'Base',
            nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
            rpcUrls: [CONFIG.BASE_RPC],
            blockExplorerUrls: ['https://basescan.org']
          }]
        });
        return true;
      } catch (addError) {
        throw new Error('Failed to add Base network');
      }
    }
    throw error;
  }
}

async function loadBalance() {
  if (!provider || !userAddress) return;
  try {
    const balance = await provider.getBalance(userAddress);
    document.getElementById('userBalance').textContent = 
      parseFloat(ethers.utils.formatEther(balance)).toFixed(4) + ' ETH';
    
    const network = await provider.getNetwork();
    document.getElementById('chainName').textContent = 
      network.chainId === CONFIG.BASE_CHAIN_ID ? 'Base ‚úì' : 'Wrong Network';
  } catch (error) {
    console.error('Balance error:', error);
  }
}

// ===================================
// Pinata IPFS Upload Functions
// ===================================

async function uploadFileToPinata(file) {
  try {
    showNotification('üì§ Uploading file to IPFS via Pinata...');
    
    const formData = new FormData();
    formData.append('file', file);
    
    const metadata = JSON.stringify({
      name: file.name,
      keyvalues: {
        uploadedBy: 'CryptoLocker',
        timestamp: Date.now()
      }
    });
    formData.append('pinataMetadata', metadata);
    
    const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
      method: 'POST',
      headers: {
        'pinata_api_key': CONFIG.PINATA.API_KEY,
        'pinata_secret_api_key': CONFIG.PINATA.API_SECRET
      },
      body: formData
    });
    
    if (!response.ok) {
      throw new Error('Pinata upload failed');
    }
    
    const result = await response.json();
    showNotification(`‚úÖ File uploaded: ${result.IpfsHash}`, 'success');
    return `ipfs://${result.IpfsHash}`;
    
  } catch (error) {
    console.error('Pinata upload error:', error);
    throw new Error('Failed to upload to IPFS: ' + error.message);
  }
}

async function uploadMetadataToPinata(metadata) {
  try {
    showNotification('üì§ Uploading metadata to IPFS...');
    
    const response = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'pinata_api_key': CONFIG.PINATA.API_KEY,
        'pinata_secret_api_key': CONFIG.PINATA.API_SECRET
      },
      body: JSON.stringify(metadata)
    });
    
    if (!response.ok) {
      throw new Error('Metadata upload failed');
    }
    
    const result = await response.json();
    showNotification(`‚úÖ Metadata uploaded: ${result.IpfsHash}`, 'success');
    return `ipfs://${result.IpfsHash}`;
    
  } catch (error) {
    console.error('Metadata upload error:', error);
    throw new Error('Failed to upload metadata: ' + error.message);
  }
}

// ===================================
// Wallet Connection Functions
// ===================================

async function connectMetaMask() {
  if (typeof window.ethereum === 'undefined') {
    showNotification('‚ö†Ô∏è MetaMask not installed!', 'error');
    return;
  }

  try {
    showNotification('üîÑ Connecting to MetaMask...');
    
    const accounts = await window.ethereum.request({ 
      method: 'eth_requestAccounts' 
    });
    
    userAddress = accounts[0];
    provider = new ethers.providers.Web3Provider(window.ethereum);
    signer = provider.getSigner();
    authType = 'MetaMask ü¶ä';
    
    await switchToBase();
    
    contract = new ethers.Contract(
      CONFIG.CONTRACT_ADDRESS,
      CONFIG.CONTRACT_ABI,
      signer
    );
    
    updateConnectionUI(true, userAddress, 'MetaMask ü¶ä');
    showNotification('‚úÖ MetaMask Connected!', 'success');
    
    await loadBalance();
    
    window.ethereum.on('accountsChanged', handleAccountsChanged);
    window.ethereum.on('chainChanged', () => window.location.reload());
    
  } catch (error) {
    console.error('MetaMask connection error:', error);
    showNotification('‚ùå Connection failed: ' + error.message, 'error');
    updateConnectionUI(false);
  }
}

async function loginWithSFA() {
  const email = document.getElementById('sfaEmail').value;
  if (!email) {
    showNotification('‚ö†Ô∏è Please enter an email', 'error');
    return;
  }

  try {
    showNotification('üîÑ Generating wallet with Web3Auth...');
    
    // Generate deterministic wallet from email
    const emailHash = ethers.utils.id(email);
    const wallet = new ethers.Wallet(emailHash);
    
    provider = new ethers.providers.JsonRpcProvider(CONFIG.BASE_RPC);
    signer = wallet.connect(provider);
    userAddress = wallet.address;
    authType = 'Web3Auth üîë';
    
    contract = new ethers.Contract(
      CONFIG.CONTRACT_ADDRESS,
      CONFIG.CONTRACT_ABI,
      signer
    );
    
    // Check if this is a returning user
    const storedWallets = JSON.parse(localStorage.getItem('sfaWallets') || '{}');
    const isReturning = storedWallets[email];
    
    // Store wallet info
    storedWallets[email] = {
      address: userAddress,
      lastLogin: Date.now()
    };
    localStorage.setItem('sfaWallets', JSON.stringify(storedWallets));
    
    // Get balance
    const balance = await provider.getBalance(userAddress);
    const balanceEth = parseFloat(ethers.utils.formatEther(balance)).toFixed(4);
    
    // Show wallet info in modal
    const walletInfo = document.getElementById('walletInfo');
    const walletMessage = document.getElementById('walletMessage');
    const walletAddress = document.getElementById('walletAddress');
    const walletBalance = document.getElementById('walletBalance');
    
    walletInfo.style.display = 'block';
    
    if (isReturning) {
      walletMessage.textContent = '‚úÖ Welcome back!';
    } else {
      walletMessage.textContent = 'üéâ New wallet created!';
    }
    
    walletAddress.textContent = `Address: ${userAddress}`;
    walletBalance.textContent = `Balance: ${balanceEth} ETH`;
    
    if (parseFloat(balanceEth) === 0) {
      walletBalance.innerHTML += '<br/>‚ö†Ô∏è Fund this wallet to use the platform';
    }
    
    updateConnectionUI(true, userAddress, 'Web3Auth üîë');
    showNotification(`‚úÖ Web3Auth Wallet ${isReturning ? 'Restored' : 'Created'}!`, 'success');
    
    await loadBalance();
    
    // Auto-close modal after 5 seconds
    setTimeout(closeSFAModal, 5000);
    
  } catch (error) {
    console.error('SFA login error:', error);
    showNotification('‚ùå Login failed: ' + error.message, 'error');
    updateConnectionUI(false);
  }
}

async function disconnect() {
  try {
    provider = null;
    signer = null;
    contract = null;
    userAddress = null;
    authType = null;
    
    updateConnectionUI(false);
    showNotification('üëã Disconnected', 'info');
    
  } catch (error) {
    console.error('Disconnect error:', error);
  }
}

function handleAccountsChanged(accounts) {
  if (accounts.length === 0) {
    showNotification('Please connect to MetaMask', 'error');
    updateConnectionUI(false);
    window.location.reload();
  } else {
    userAddress = accounts[0];
    updateConnectionUI(true, userAddress, 'MetaMask ü¶ä');
    loadBalance();
  }
}

// ===================================
// Smart Contract Functions
// ===================================

async function mintNFT(name, description, contentType, file) {
  if (!contract) {
    showNotification('‚ö†Ô∏è Please connect wallet first!', 'error');
    return;
  }

  try {
    // Check and switch network FIRST
    await checkAndSwitchNetwork();
    
    // Step 1: Upload file to IPFS (if provided)
    let ipfsUrl = "";
    if (file) {
      ipfsUrl = await uploadFileToPinata(file);
    }
    
    // Step 2: Create and upload metadata
    const metadata = {
      name: name,
      description: description,
      image: ipfsUrl,
      attributes: [
        { trait_type: "Content Type", value: contentType },
        { trait_type: "Created", value: new Date().toISOString() }
      ]
    };
    
    const tokenURI = await uploadMetadataToPinata(metadata);
    
    // Step 3: Mint NFT on blockchain
    showNotification('üîÑ Minting NFT on Base...');
    const mintFee = ethers.utils.parseEther("0.01");

    const tx = await contract.mintNFT(
      name,
      description,
      contentType,
      ipfsUrl,
      0,
      tokenURI,
      { value: mintFee }
    );

    showNotification('‚è≥ Transaction sent! Waiting for confirmation...');
    const receipt = await tx.wait();
    
    showNotification('‚úÖ NFT Minted Successfully! TX: ' + receipt.transactionHash.slice(0, 10) + '...', 'success');
    
    document.getElementById('quickMintForm').reset();
    await loadBalance();
    
  } catch (error) {
    console.error('Mint error:', error);
    const errorMsg = error.reason || error.data?.message || error.message;
    showNotification('‚ùå Mint failed: ' + errorMsg, 'error');
  }
}

async function createCollection(name, description) {
  if (!contract) {
    showNotification('‚ö†Ô∏è Please connect wallet first!', 'error');
    return;
  }

  try {
    // Check and switch network FIRST
    await checkAndSwitchNetwork();
    
    showNotification('üîÑ Creating collection...');
    const tx = await contract.createCollection(name, description);
    
    showNotification('‚è≥ Transaction sent! Waiting for confirmation...');
    await tx.wait();
    
    showNotification('‚úÖ Collection Created!', 'success');
    document.getElementById('createCollectionForm').reset();
    
  } catch (error) {
    console.error('Collection error:', error);
    const errorMsg = error.reason || error.data?.message || error.message;
    showNotification('‚ùå Failed: ' + errorMsg, 'error');
  }
}

async function lockTokens(tokenAddress, amount, duration, useYield) {
  if (!contract) {
    showNotification('‚ö†Ô∏è Please connect wallet first!', 'error');
    return;
  }

  try {
    // Check and switch network FIRST
    await checkAndSwitchNetwork();
    
    // Validate inputs
    if (!ethers.utils.isAddress(tokenAddress)) {
      showNotification('‚ùå Invalid token address', 'error');
      return;
    }
    
    if (!amount || parseFloat(amount) <= 0) {
      showNotification('‚ùå Amount must be greater than 0', 'error');
      return;
    }
    
    showNotification('üîç Checking token details...');
    
    // Get token contract
    const tokenContract = new ethers.Contract(
      tokenAddress,
      [
        "function symbol() view returns (string)",
        "function decimals() view returns (uint8)",
        "function balanceOf(address) view returns (uint256)",
        "function allowance(address owner, address spender) view returns (uint256)",
        "function approve(address spender, uint256 amount) returns (bool)"
      ],
      signer
    );
    
    // Get token info
    let tokenSymbol, tokenDecimals;
    try {
      tokenSymbol = await tokenContract.symbol();
      tokenDecimals = await tokenContract.decimals();
      showNotification(`‚úÖ Found: ${tokenSymbol} (${tokenDecimals} decimals)`);
    } catch (error) {
      showNotification('‚ùå Failed to read token details. Invalid token?', 'error');
      return;
    }
    
    // Check balance
    const balance = await tokenContract.balanceOf(userAddress);
    const amountWei = ethers.utils.parseUnits(amount.toString(), tokenDecimals);
    
    if (balance.lt(amountWei)) {
      const formattedBalance = ethers.utils.formatUnits(balance, tokenDecimals);
      showNotification(`‚ùå Insufficient balance. You have: ${formattedBalance} ${tokenSymbol}`, 'error');
      return;
    }
    
    showNotification(`‚úÖ Balance: ${ethers.utils.formatUnits(balance, tokenDecimals)} ${tokenSymbol}`);
    
    // Check and handle approval
    const currentAllowance = await tokenContract.allowance(userAddress, CONFIG.CONTRACT_ADDRESS);
    
    if (currentAllowance.lt(amountWei)) {
      showNotification(`üîì Approving ${tokenSymbol}...`);
      
      // Some tokens (like USDT) require resetting allowance to 0 first
      if (currentAllowance.gt(0)) {
        const resetTx = await tokenContract.approve(CONFIG.CONTRACT_ADDRESS, 0);
        await resetTx.wait();
        showNotification('üîÑ Resetting allowance...');
      }
      
      const approveTx = await tokenContract.approve(CONFIG.CONTRACT_ADDRESS, amountWei);
      showNotification('‚è≥ Waiting for approval...');
      await approveTx.wait();
      showNotification(`‚úÖ ${tokenSymbol} approved!`, 'success');
    } else {
      showNotification(`‚úÖ ${tokenSymbol} already approved`);
    }
    
    // Lock tokens
    const durationDays = Math.floor(duration / 86400);
    showNotification(`üîí Locking ${amount} ${tokenSymbol} for ${durationDays} days...`);
    
    const lockTx = await contract.lockTokens(tokenAddress, amountWei, duration, useYield);
    showNotification('‚è≥ Transaction sent! Waiting for confirmation...');
    await lockTx.wait();
    
    const yieldMsg = useYield ? ' with Aave yield üìà' : '';
    showNotification(`‚úÖ Locked ${amount} ${tokenSymbol} for ${durationDays} days${yieldMsg}`, 'success');
    
    document.getElementById('lockForm').reset();
    
  } catch (error) {
    console.error('Lock error:', error);
    
    let errorMsg = 'Unknown error';
    if (error.code === 4001) {
      errorMsg = 'Transaction rejected by user';
    } else if (error.code === -32000) {
      errorMsg = 'Insufficient ETH for gas fees';
    } else if (error.message.includes('approve')) {
      errorMsg = 'Token approval failed - try again';
    } else {
      errorMsg = error.reason || error.data?.message || error.message;
    }
    
    showNotification('‚ùå Failed: ' + errorMsg, 'error');
  }
}

// ===================================
// Event Listeners
// ===================================

window.addEventListener('load', () => {
  document.getElementById('connectMetaMask').addEventListener('click', connectMetaMask);
  document.getElementById('connectSFA').addEventListener('click', openSFAModal);
  document.getElementById('disconnectBtn').addEventListener('click', disconnect);

  document.getElementById('quickMintForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const name = document.getElementById('nftName').value;
    const description = document.getElementById('nftDescription').value;
    const contentType = document.getElementById('contentType').value;
    const file = document.getElementById('nftFile').files[0];
    await mintNFT(name, description, contentType, file);
  });

  document.getElementById('createCollectionForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const name = document.getElementById('collectionName').value;
    const description = document.getElementById('collectionDescription').value;
    await createCollection(name, description);
  });

  document.getElementById('lockForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const tokenAddress = document.getElementById('tokenAddress').value;
    const amount = document.getElementById('lockAmount').value;
    const duration = parseInt(document.getElementById('lockDuration').value) * 86400;
    const useYield = document.getElementById('useYield').checked;
    await lockTokens(tokenAddress, amount, duration, useYield);
  });
});
